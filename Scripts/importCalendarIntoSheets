/************ CONFIG ************/
const CFG2 = {
  sheetName: "Calendario",     // nombre de la hoja
  headerRow: 1,                // fila donde están Monday..Sunday
  timeCol: 1,                  // columna A = horas
  clearGridBeforeImport: true,
  maxRowsToScan: 400,

  // Máximo de columnas de "solape" a la derecha que permitimos usar
  // (si tienes columnas en blanco entre días, esto te crea "carriles" de solape)
  maxOverlapShift: 12,

  // null = todos los calendarios visibles
  // ["Tareas", "Estudio"] = solo esos
  calendarNames: null,

  // Subjects source
  subjectsSheetName: "database",
  subjectsRangeA1: "J5:J12",

  // NUEVO: salida en MainDashboard
  outputSheetName: "MainDashboard",
  outEstudioA1: "J16",
  outProyectoA1: "M19",
  outTareasA1: "M20",
  outSubjectsStartA1: "M11" // M11:M18
};

/************ ENTRYPOINTS ************/
function importWeekFromToday() {
  importWeek_(new Date());
  Utilities.sleep(500);
  renderMainDashboard_G4_values();
  Utilities.sleep(500);
  updateEstudioWeekAndTotalSums();
}

function importWeekFromCellB1() {
  const sh = SpreadsheetApp.getActive().getSheetByName(CFG2.sheetName);
  const v = sh.getRange("B1").getValue();
  const d = (v instanceof Date) ? v : new Date(v);
  importWeek_(d);
}

/************ CORE ************/
function importWeek_(anyDate) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName(CFG2.sheetName);
  if (!sh) throw new Error(`No existe la hoja "${CFG2.sheetName}"`);

  // NUEVO: exportar lista de asignaturas desde database!J5:J12 antes de importar (preservando orden)
  const subjectsInfo = getSubjectsFromDatabaseWithOrder_(); // { list, rawValues }
  const subjects = subjectsInfo.list;         // lista ordenada, sin vacíos, sin duplicados
  const rawOrdered = subjectsInfo.rawValues;  // exactamente J5:J12 (trimmed), para mapear M11:M18 por índice

  // NUEVO: contadores (30-min blocks)
  const counters = {
    byType30m: {
      "Estudio": 0,
      "Proyecto": 0,
      "Tareas": 0
    },
    bySubject30m: {} // solo Estudio, por asignatura
  };

  // Inicializa contadores por asignatura (para que salgan 0 explícitos)
  for (const s of subjects) {
    counters.bySubject30m[s] = 0;
  }

  // Mapas
  const dayCols = buildDayColumns_(sh);
  const timeRows = buildTimeRows_(sh);

  // Límites por día para NO invadir el siguiente día al desplazar a la derecha
  const dayBounds = buildDayBounds_(sh, dayCols);

  // Semana (lunes 00:00 → lunes siguiente)
  const weekStart = startOfWeekMonday_(anyDate);
  const weekEnd   = new Date(weekStart.getTime() + 7 * 24 * 60 * 60 * 1000);

  // LIMPIEZA TOTAL + UNMERGE (incluyendo columnas usadas para solapes)
  if (CFG2.clearGridBeforeImport) {
    clearGrid_(sh, timeRows, dayCols, dayBounds);
  }

  // Calendarios
  const calendars = getCalendars_();

  // cache de carril por (día + evento)
  const laneByDayEventKey = {};

  // Importación
  for (const cal of calendars) {
    const calName = cal.getName();
    const events = cal.getEvents(weekStart, weekEnd);

    for (const ev of events) {
      if (ev.isAllDayEvent && ev.isAllDayEvent()) continue;

      const title = String(ev.getTitle() || "").trim();
      const label = `[${calName}] ${title || "(Sin título)"}`;

      const s = ceilTo30_(ev.getStartTime());
      let   e = ceilTo30_(ev.getEndTime());

      if (e <= s) {
        e = new Date(s.getTime() + 30 * 60 * 1000);
      }

      // ID estable del evento (si existe); fallback robusto si no.
      const evId = (typeof ev.getId === "function" && ev.getId())
        ? ev.getId()
        : (calName + "||" + (ev.getTitle() || "") + "||" + s.getTime() + "||" + e.getTime());

      let cur = new Date(s);
      while (cur < e) {
        const dayKey = dayKeyFromDate_(cur);
        const baseCol = dayCols[dayKey];
        const row = timeRows[hhmm_(cur)];

        if (baseCol && row) {
          const laneKey = dayKey + "||" + evId;

          if (!laneByDayEventKey[laneKey]) {
            const chosen = findPlacementCol_(sh, row, dayKey, baseCol, dayBounds);
            laneByDayEventKey[laneKey] = chosen || baseCol;
          }

          const destCol = laneByDayEventKey[laneKey];

          // Seguridad: no invadir cabecera del siguiente día
          const b = dayBounds[dayKey];
          if (b && destCol <= b.rightLimit) {
            // CONTAR BLOQUES (30 min) de Estudio/Proyecto/Tareas
            if (calName === "Estudio" || calName === "Proyecto" || calName === "Tareas") {
              counters.byType30m[calName] = (counters.byType30m[calName] || 0) + 1;

              // CONTAR por asignatura (solo Estudio) si coincide con la lista
              if (calName === "Estudio") {
                const concept = title;
                if (concept && Object.prototype.hasOwnProperty.call(counters.bySubject30m, concept)) {
                  counters.bySubject30m[concept] += 1;
                }
              }
            }

            const cell = sh.getRange(row, destCol);
            const prev = String(cell.getValue() || "").trim();

            if (!prev) {
              cell.setValue(label);
            } else if (!prev.split("\n").includes(label)) {
              cell.setValue(prev + "\n" + label);
            }
          }
        }

        cur = new Date(cur.getTime() + 30 * 60 * 1000);
      }
    }
  }

  // MERGE DE BLOQUES CONSECUTIVOS (incluye carriles de solape)
  mergeConsecutiveCells_(sh, timeRows, dayBounds);

  // NUEVO: salida a MainDashboard en HORAS
  writeWeeklyCountsToMainDashboard_(ss, counters, rawOrdered);
}

/************ HELPERS ************/
function writeWeeklyCountsToMainDashboard_(ss, counters, rawOrderedSubjects) {
  const shOut = ss.getSheetByName("MainDashboard");
  if (!shOut) throw new Error(`No existe la hoja "${CFG2.outputSheetName}"`);

  const toHours = (n30) => (Number(n30 || 0) * 0.5);

  // Totales por tipo
  shOut.getRange(CFG2.outEstudioA1).setValue(toHours(counters.byType30m["Estudio"] || 0));
  shOut.getRange(CFG2.outProyectoA1).setValue(toHours(counters.byType30m["Proyecto"] || 0));
  shOut.getRange(CFG2.outTareasA1).setValue(toHours(counters.byType30m["Tareas"] || 0));

  // Asignaturas: M11:M18 mapeado por índice con database!J5:J12 (mismo orden)
  const start = shOut.getRange(CFG2.outSubjectsStartA1);
  const startRow = start.getRow();
  const startCol = start.getColumn();

  const outVals = [];
  for (let i = 0; i < rawOrderedSubjects.length; i++) {
    const subj = String(rawOrderedSubjects[i] || "").trim();
    if (!subj) {
      outVals.push([""]); // si en J hay vacío, deja vacío en M
      continue;
    }
    const n30 = (counters.bySubject30m && Object.prototype.hasOwnProperty.call(counters.bySubject30m, subj))
      ? counters.bySubject30m[subj]
      : 0;
    outVals.push([toHours(n30)]);
  }

  shOut.getRange(startRow, startCol, outVals.length, 1).setValues(outVals);
}

function getSubjectsFromDatabaseWithOrder_() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName(CFG2.subjectsSheetName);
  if (!sh) throw new Error(`No existe la hoja "${CFG2.subjectsSheetName}"`);

  const raw = sh.getRange(CFG2.subjectsRangeA1).getValues().flat();
  const rawTrimmed = raw.map(v => String(v || "").trim());

  // lista sin vacíos y sin duplicados, preservando primer orden de aparición
  const list = [];
  const seen = new Set();
  for (const s of rawTrimmed) {
    if (!s) continue;
    if (seen.has(s)) continue;
    seen.add(s);
    list.push(s);
  }

  return { list, rawValues: rawTrimmed };
}

function buildDayColumns_(sh) {
  const lastCol = sh.getLastColumn();
  const headers = sh
    .getRange(CFG2.headerRow, 1, 1, lastCol)
    .getDisplayValues()[0];

  const wanted = new Set([
    "Monday", "Tuesday", "Wednesday",
    "Thursday", "Friday", "Saturday", "Sunday"
  ]);

  const map = {};
  for (let c = 0; c < headers.length; c++) {
    const h = String(headers[c] || "").trim();
    if (wanted.has(h)) {
      map[h] = c + 1;
    }
  }

  if (Object.keys(map).length === 0) {
    throw new Error("No se han encontrado cabeceras Monday..Sunday");
  }

  return map;
}

function buildDayBounds_(sh, dayCols) {
  const lastCol = sh.getLastColumn();

  const entries = Object.entries(dayCols)
    .map(([k, c]) => ({ dayKey: k, col: c }))
    .sort((a, b) => a.col - b.col);

  const bounds = {};
  for (let i = 0; i < entries.length; i++) {
    const cur = entries[i];
    const next = entries[i + 1];

    const baseCol = cur.col;
    const rightLimit = next ? (next.col - 1) : lastCol;

    bounds[cur.dayKey] = {
      baseCol,
      rightLimit
    };
  }

  return bounds;
}

function buildTimeRows_(sh) {
  const disp = sh
    .getRange(1, CFG2.timeCol, CFG2.maxRowsToScan, 1)
    .getDisplayValues()
    .flat();

  const vals = sh
    .getRange(1, CFG2.timeCol, CFG2.maxRowsToScan, 1)
    .getValues()
    .flat();

  const map = {};

  for (let r = 0; r < disp.length; r++) {
    const v = String(disp[r] || "").trim();
    const m = v.match(/^(\d{1,2}):(\d{2})(?::\d{2})?$/);
    if (m) {
      map[pad2_(m[1]) + ":" + m[2]] = r + 1;
      continue;
    }

    const raw = vals[r];
    if (raw instanceof Date && !isNaN(raw)) {
      map[pad2_(raw.getHours()) + ":" + pad2_(raw.getMinutes())] = r + 1;
    }
  }

  if (Object.keys(map).length === 0) {
    throw new Error("No hay horas HH:MM en la columna A");
  }

  return map;
}

function clearGrid_(sh, timeRows, dayCols, dayBounds) {
  const rows = Object.values(timeRows);
  const minRow = Math.min(...rows);
  const maxRow = Math.max(...rows);

  const baseCols = Object.values(dayCols);
  const minCol = Math.min(...baseCols);

  let maxRight = minCol;
  for (const b of Object.values(dayBounds)) {
    if (b.rightLimit > maxRight) maxRight = b.rightLimit;
  }

  const rng = sh.getRange(minRow, minCol, maxRow - minRow + 1, maxRight - minCol + 1);
  rng.breakApart();
  rng.clearContent();
}

function findPlacementCol_(sh, row, dayKey, baseCol, dayBounds) {
  const b = dayBounds[dayKey];
  if (!b) return null;

  const maxShift = CFG2.maxOverlapShift || 0;
  const rightLimit = b.rightLimit;

  for (let shift = 0; shift <= maxShift; shift++) {
    const col = baseCol + shift;
    if (col > rightLimit) break;

    const v = String(sh.getRange(row, col).getValue() || "").trim();
    if (!v) return col;
  }

  return baseCol;
}

function mergeConsecutiveCells_(sh, timeRows, dayBounds) {
  const rows = Object.values(timeRows);
  const minRow = Math.min(...rows);
  const maxRow = Math.max(...rows);
  const height = maxRow - minRow + 1;

  for (const b of Object.values(dayBounds)) {
    for (let col = b.baseCol; col <= b.rightLimit; col++) {
      const rng = sh.getRange(minRow, col, height, 1);
      const vals = rng.getValues();

      let start = 0;
      for (let i = 1; i <= vals.length; i++) {
        const cur = i < vals.length ? String(vals[i][0] || "").trim() : null;
        const base = String(vals[start][0] || "").trim();

        if (cur !== base) {
          const len = i - start;

          if (len > 1 && base !== "") {
            for (let k = start + 1; k < i; k++) {
              vals[k][0] = "";
            }
            rng.setValues(vals);
            sh.getRange(minRow + start, col, len, 1).merge();
          }

          start = i;
        }
      }
    }
  }
}

function getCalendars_() {
  const all = CalendarApp.getAllCalendars();
  if (!CFG2.calendarNames) return all;
  const wanted = new Set(CFG2.calendarNames.map(s => String(s).trim()));
  return all.filter(c => wanted.has(c.getName()));
}

function startOfWeekMonday_(d) {
  const x = new Date(d);
  x.setHours(0, 0, 0, 0);
  const day = x.getDay();
  const diff = day === 0 ? -6 : 1 - day;
  x.setDate(x.getDate() + diff);
  return x;
}

function ceilTo30_(d) {
  const x = new Date(d);
  x.setSeconds(0, 0);
  const m = x.getMinutes();
  if (m === 0 || m === 30) return x;
  x.setMinutes(m < 30 ? 30 : 60);
  return x;
}

function hhmm_(d) {
  return pad2_(d.getHours()) + ":" + pad2_(d.getMinutes());
}

function pad2_(n) {
  return String(n).padStart(2, "0");
}

function dayKeyFromDate_(d) {
  return ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"][d.getDay()];
}
